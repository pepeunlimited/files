// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/facebookincubator/ent/dialect/sql"
	"github.com/facebookincubator/ent/dialect/sql/sqlgraph"
	"github.com/facebookincubator/ent/schema/field"
	"github.com/pepeunlimited/files/internal/pkg/ent/bucket"
	"github.com/pepeunlimited/files/internal/pkg/ent/file"
	"github.com/pepeunlimited/files/internal/pkg/ent/predicate"
)

// FileUpdate is the builder for updating File entities.
type FileUpdate struct {
	config
	filename       *string
	mime_type      *string
	file_size      *int64
	addfile_size   *int64
	is_draft       *bool
	is_deleted     *bool
	user_id        *int64
	adduser_id     *int64
	created_at     *time.Time
	updated_at     *time.Time
	buckets        map[int]struct{}
	clearedBuckets bool
	predicates     []predicate.File
}

// Where adds a new predicate for the builder.
func (fu *FileUpdate) Where(ps ...predicate.File) *FileUpdate {
	fu.predicates = append(fu.predicates, ps...)
	return fu
}

// SetFilename sets the filename field.
func (fu *FileUpdate) SetFilename(s string) *FileUpdate {
	fu.filename = &s
	return fu
}

// SetMimeType sets the mime_type field.
func (fu *FileUpdate) SetMimeType(s string) *FileUpdate {
	fu.mime_type = &s
	return fu
}

// SetFileSize sets the file_size field.
func (fu *FileUpdate) SetFileSize(i int64) *FileUpdate {
	fu.file_size = &i
	fu.addfile_size = nil
	return fu
}

// AddFileSize adds i to file_size.
func (fu *FileUpdate) AddFileSize(i int64) *FileUpdate {
	if fu.addfile_size == nil {
		fu.addfile_size = &i
	} else {
		*fu.addfile_size += i
	}
	return fu
}

// SetIsDraft sets the is_draft field.
func (fu *FileUpdate) SetIsDraft(b bool) *FileUpdate {
	fu.is_draft = &b
	return fu
}

// SetNillableIsDraft sets the is_draft field if the given value is not nil.
func (fu *FileUpdate) SetNillableIsDraft(b *bool) *FileUpdate {
	if b != nil {
		fu.SetIsDraft(*b)
	}
	return fu
}

// SetIsDeleted sets the is_deleted field.
func (fu *FileUpdate) SetIsDeleted(b bool) *FileUpdate {
	fu.is_deleted = &b
	return fu
}

// SetNillableIsDeleted sets the is_deleted field if the given value is not nil.
func (fu *FileUpdate) SetNillableIsDeleted(b *bool) *FileUpdate {
	if b != nil {
		fu.SetIsDeleted(*b)
	}
	return fu
}

// SetUserID sets the user_id field.
func (fu *FileUpdate) SetUserID(i int64) *FileUpdate {
	fu.user_id = &i
	fu.adduser_id = nil
	return fu
}

// AddUserID adds i to user_id.
func (fu *FileUpdate) AddUserID(i int64) *FileUpdate {
	if fu.adduser_id == nil {
		fu.adduser_id = &i
	} else {
		*fu.adduser_id += i
	}
	return fu
}

// SetCreatedAt sets the created_at field.
func (fu *FileUpdate) SetCreatedAt(t time.Time) *FileUpdate {
	fu.created_at = &t
	return fu
}

// SetUpdatedAt sets the updated_at field.
func (fu *FileUpdate) SetUpdatedAt(t time.Time) *FileUpdate {
	fu.updated_at = &t
	return fu
}

// SetBucketsID sets the buckets edge to Bucket by id.
func (fu *FileUpdate) SetBucketsID(id int) *FileUpdate {
	if fu.buckets == nil {
		fu.buckets = make(map[int]struct{})
	}
	fu.buckets[id] = struct{}{}
	return fu
}

// SetNillableBucketsID sets the buckets edge to Bucket by id if the given value is not nil.
func (fu *FileUpdate) SetNillableBucketsID(id *int) *FileUpdate {
	if id != nil {
		fu = fu.SetBucketsID(*id)
	}
	return fu
}

// SetBuckets sets the buckets edge to Bucket.
func (fu *FileUpdate) SetBuckets(b *Bucket) *FileUpdate {
	return fu.SetBucketsID(b.ID)
}

// ClearBuckets clears the buckets edge to Bucket.
func (fu *FileUpdate) ClearBuckets() *FileUpdate {
	fu.clearedBuckets = true
	return fu
}

// Save executes the query and returns the number of rows/vertices matched by this operation.
func (fu *FileUpdate) Save(ctx context.Context) (int, error) {
	if fu.filename != nil {
		if err := file.FilenameValidator(*fu.filename); err != nil {
			return 0, fmt.Errorf("ent: validator failed for field \"filename\": %v", err)
		}
	}
	if fu.mime_type != nil {
		if err := file.MimeTypeValidator(*fu.mime_type); err != nil {
			return 0, fmt.Errorf("ent: validator failed for field \"mime_type\": %v", err)
		}
	}
	if len(fu.buckets) > 1 {
		return 0, errors.New("ent: multiple assignments on a unique edge \"buckets\"")
	}
	return fu.sqlSave(ctx)
}

// SaveX is like Save, but panics if an error occurs.
func (fu *FileUpdate) SaveX(ctx context.Context) int {
	affected, err := fu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (fu *FileUpdate) Exec(ctx context.Context) error {
	_, err := fu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (fu *FileUpdate) ExecX(ctx context.Context) {
	if err := fu.Exec(ctx); err != nil {
		panic(err)
	}
}

func (fu *FileUpdate) sqlSave(ctx context.Context) (n int, err error) {
	_spec := &sqlgraph.UpdateSpec{
		Node: &sqlgraph.NodeSpec{
			Table:   file.Table,
			Columns: file.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: file.FieldID,
			},
		},
	}
	if ps := fu.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value := fu.filename; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  *value,
			Column: file.FieldFilename,
		})
	}
	if value := fu.mime_type; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  *value,
			Column: file.FieldMimeType,
		})
	}
	if value := fu.file_size; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeInt64,
			Value:  *value,
			Column: file.FieldFileSize,
		})
	}
	if value := fu.addfile_size; value != nil {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeInt64,
			Value:  *value,
			Column: file.FieldFileSize,
		})
	}
	if value := fu.is_draft; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeBool,
			Value:  *value,
			Column: file.FieldIsDraft,
		})
	}
	if value := fu.is_deleted; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeBool,
			Value:  *value,
			Column: file.FieldIsDeleted,
		})
	}
	if value := fu.user_id; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeInt64,
			Value:  *value,
			Column: file.FieldUserID,
		})
	}
	if value := fu.adduser_id; value != nil {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeInt64,
			Value:  *value,
			Column: file.FieldUserID,
		})
	}
	if value := fu.created_at; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  *value,
			Column: file.FieldCreatedAt,
		})
	}
	if value := fu.updated_at; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  *value,
			Column: file.FieldUpdatedAt,
		})
	}
	if fu.clearedBuckets {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   file.BucketsTable,
			Columns: []string{file.BucketsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: bucket.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := fu.buckets; len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   file.BucketsTable,
			Columns: []string{file.BucketsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: bucket.FieldID,
				},
			},
		}
		for k, _ := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if n, err = sqlgraph.UpdateNodes(ctx, fu.driver, _spec); err != nil {
		if cerr, ok := isSQLConstraintError(err); ok {
			err = cerr
		}
		return 0, err
	}
	return n, nil
}

// FileUpdateOne is the builder for updating a single File entity.
type FileUpdateOne struct {
	config
	id             int
	filename       *string
	mime_type      *string
	file_size      *int64
	addfile_size   *int64
	is_draft       *bool
	is_deleted     *bool
	user_id        *int64
	adduser_id     *int64
	created_at     *time.Time
	updated_at     *time.Time
	buckets        map[int]struct{}
	clearedBuckets bool
}

// SetFilename sets the filename field.
func (fuo *FileUpdateOne) SetFilename(s string) *FileUpdateOne {
	fuo.filename = &s
	return fuo
}

// SetMimeType sets the mime_type field.
func (fuo *FileUpdateOne) SetMimeType(s string) *FileUpdateOne {
	fuo.mime_type = &s
	return fuo
}

// SetFileSize sets the file_size field.
func (fuo *FileUpdateOne) SetFileSize(i int64) *FileUpdateOne {
	fuo.file_size = &i
	fuo.addfile_size = nil
	return fuo
}

// AddFileSize adds i to file_size.
func (fuo *FileUpdateOne) AddFileSize(i int64) *FileUpdateOne {
	if fuo.addfile_size == nil {
		fuo.addfile_size = &i
	} else {
		*fuo.addfile_size += i
	}
	return fuo
}

// SetIsDraft sets the is_draft field.
func (fuo *FileUpdateOne) SetIsDraft(b bool) *FileUpdateOne {
	fuo.is_draft = &b
	return fuo
}

// SetNillableIsDraft sets the is_draft field if the given value is not nil.
func (fuo *FileUpdateOne) SetNillableIsDraft(b *bool) *FileUpdateOne {
	if b != nil {
		fuo.SetIsDraft(*b)
	}
	return fuo
}

// SetIsDeleted sets the is_deleted field.
func (fuo *FileUpdateOne) SetIsDeleted(b bool) *FileUpdateOne {
	fuo.is_deleted = &b
	return fuo
}

// SetNillableIsDeleted sets the is_deleted field if the given value is not nil.
func (fuo *FileUpdateOne) SetNillableIsDeleted(b *bool) *FileUpdateOne {
	if b != nil {
		fuo.SetIsDeleted(*b)
	}
	return fuo
}

// SetUserID sets the user_id field.
func (fuo *FileUpdateOne) SetUserID(i int64) *FileUpdateOne {
	fuo.user_id = &i
	fuo.adduser_id = nil
	return fuo
}

// AddUserID adds i to user_id.
func (fuo *FileUpdateOne) AddUserID(i int64) *FileUpdateOne {
	if fuo.adduser_id == nil {
		fuo.adduser_id = &i
	} else {
		*fuo.adduser_id += i
	}
	return fuo
}

// SetCreatedAt sets the created_at field.
func (fuo *FileUpdateOne) SetCreatedAt(t time.Time) *FileUpdateOne {
	fuo.created_at = &t
	return fuo
}

// SetUpdatedAt sets the updated_at field.
func (fuo *FileUpdateOne) SetUpdatedAt(t time.Time) *FileUpdateOne {
	fuo.updated_at = &t
	return fuo
}

// SetBucketsID sets the buckets edge to Bucket by id.
func (fuo *FileUpdateOne) SetBucketsID(id int) *FileUpdateOne {
	if fuo.buckets == nil {
		fuo.buckets = make(map[int]struct{})
	}
	fuo.buckets[id] = struct{}{}
	return fuo
}

// SetNillableBucketsID sets the buckets edge to Bucket by id if the given value is not nil.
func (fuo *FileUpdateOne) SetNillableBucketsID(id *int) *FileUpdateOne {
	if id != nil {
		fuo = fuo.SetBucketsID(*id)
	}
	return fuo
}

// SetBuckets sets the buckets edge to Bucket.
func (fuo *FileUpdateOne) SetBuckets(b *Bucket) *FileUpdateOne {
	return fuo.SetBucketsID(b.ID)
}

// ClearBuckets clears the buckets edge to Bucket.
func (fuo *FileUpdateOne) ClearBuckets() *FileUpdateOne {
	fuo.clearedBuckets = true
	return fuo
}

// Save executes the query and returns the updated entity.
func (fuo *FileUpdateOne) Save(ctx context.Context) (*File, error) {
	if fuo.filename != nil {
		if err := file.FilenameValidator(*fuo.filename); err != nil {
			return nil, fmt.Errorf("ent: validator failed for field \"filename\": %v", err)
		}
	}
	if fuo.mime_type != nil {
		if err := file.MimeTypeValidator(*fuo.mime_type); err != nil {
			return nil, fmt.Errorf("ent: validator failed for field \"mime_type\": %v", err)
		}
	}
	if len(fuo.buckets) > 1 {
		return nil, errors.New("ent: multiple assignments on a unique edge \"buckets\"")
	}
	return fuo.sqlSave(ctx)
}

// SaveX is like Save, but panics if an error occurs.
func (fuo *FileUpdateOne) SaveX(ctx context.Context) *File {
	f, err := fuo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return f
}

// Exec executes the query on the entity.
func (fuo *FileUpdateOne) Exec(ctx context.Context) error {
	_, err := fuo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (fuo *FileUpdateOne) ExecX(ctx context.Context) {
	if err := fuo.Exec(ctx); err != nil {
		panic(err)
	}
}

func (fuo *FileUpdateOne) sqlSave(ctx context.Context) (f *File, err error) {
	_spec := &sqlgraph.UpdateSpec{
		Node: &sqlgraph.NodeSpec{
			Table:   file.Table,
			Columns: file.Columns,
			ID: &sqlgraph.FieldSpec{
				Value:  fuo.id,
				Type:   field.TypeInt,
				Column: file.FieldID,
			},
		},
	}
	if value := fuo.filename; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  *value,
			Column: file.FieldFilename,
		})
	}
	if value := fuo.mime_type; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  *value,
			Column: file.FieldMimeType,
		})
	}
	if value := fuo.file_size; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeInt64,
			Value:  *value,
			Column: file.FieldFileSize,
		})
	}
	if value := fuo.addfile_size; value != nil {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeInt64,
			Value:  *value,
			Column: file.FieldFileSize,
		})
	}
	if value := fuo.is_draft; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeBool,
			Value:  *value,
			Column: file.FieldIsDraft,
		})
	}
	if value := fuo.is_deleted; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeBool,
			Value:  *value,
			Column: file.FieldIsDeleted,
		})
	}
	if value := fuo.user_id; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeInt64,
			Value:  *value,
			Column: file.FieldUserID,
		})
	}
	if value := fuo.adduser_id; value != nil {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeInt64,
			Value:  *value,
			Column: file.FieldUserID,
		})
	}
	if value := fuo.created_at; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  *value,
			Column: file.FieldCreatedAt,
		})
	}
	if value := fuo.updated_at; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  *value,
			Column: file.FieldUpdatedAt,
		})
	}
	if fuo.clearedBuckets {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   file.BucketsTable,
			Columns: []string{file.BucketsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: bucket.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := fuo.buckets; len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   file.BucketsTable,
			Columns: []string{file.BucketsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: bucket.FieldID,
				},
			},
		}
		for k, _ := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	f = &File{config: fuo.config}
	_spec.Assign = f.assignValues
	_spec.ScanValues = f.scanValues()
	if err = sqlgraph.UpdateNode(ctx, fuo.driver, _spec); err != nil {
		if cerr, ok := isSQLConstraintError(err); ok {
			err = cerr
		}
		return nil, err
	}
	return f, nil
}
